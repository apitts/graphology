{"version":3,"file":"graphology.cjs.js","sources":["../src/utils.js","../src/errors.js","../src/data.js","../src/attributes/nodes.js","../src/attributes/edges.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.cjs.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' && value !== null && value.constructor === Object\n  );\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n","/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n","/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return new Iterator(function next() {\n    do {\n      if (!edgeData) {\n        if (i >= l) return {done: true};\n\n        const k = keys[i++];\n\n        if (k === avoid) {\n          edgeData = undefined;\n          continue;\n        }\n\n        edgeData = object[k];\n      } else {\n        edgeData = edgeData.next;\n      }\n    } while (!edgeData);\n\n    return {\n      done: false,\n      value: {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      }\n    };\n  });\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return new Iterator(function () {\n      if (!edgeData) return {done: true};\n\n      const value = {\n        edge: edgeData.key,\n        attributes: edgeData.attributes,\n        source: edgeData.source.key,\n        target: edgeData.target.key,\n        sourceAttributes: edgeData.source.attributes,\n        targetAttributes: edgeData.target.attributes,\n        undirected: edgeData.undirected\n      };\n\n      edgeData = edgeData.next;\n\n      return {\n        done: false,\n        value\n      };\n    });\n  }\n\n  return Iterator.of({\n    edge: edgeData.key,\n    attributes: edgeData.attributes,\n    source: edgeData.source.key,\n    target: edgeData.target.key,\n    sourceAttributes: edgeData.source.attributes,\n    targetAttributes: edgeData.target.attributes,\n    undirected: edgeData.undirected\n  });\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    if (typeof Array.from === 'function')\n      return Array.from(graph._edges.keys());\n\n    return take(graph._edges.keys(), graph._edges.size);\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return Iterator.empty();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    let step, data;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      step = iterator.next();\n\n      if (step.done) return step;\n\n      data = step.value;\n\n      if (shouldFilter && data.undirected !== mask) continue;\n\n      break;\n    }\n\n    const value = {\n      edge: data.key,\n      attributes: data.attributes,\n      source: data.source.key,\n      target: data.target.key,\n      sourceAttributes: data.source.attributes,\n      targetAttributes: data.target.attributes,\n      undirected: data.undirected\n    };\n\n    return {value, done: false};\n  });\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    let neighborData = null;\n\n    do {\n      if (i >= l) {\n        if (visited) visited.wrap(object);\n        return {done: true};\n      }\n\n      const edgeData = object[keys[i++]];\n\n      const sourceData = edgeData.source;\n      const targetData = edgeData.target;\n\n      neighborData = sourceData === nodeData ? targetData : sourceData;\n\n      if (visited && visited.has(neighborData.key)) {\n        neighborData = null;\n        continue;\n      }\n    } while (neighborData === null);\n\n    return {\n      done: false,\n      value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\nimport {InvalidArgumentsGraphError} from './errors';\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {forEachAdjacency} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) graph._undirectedSelfLoopCount++;\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) graph._directedSelfLoopCount++;\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) graph._undirectedSelfLoopCount++;\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) graph._directedSelfLoopCount++;\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) graph._undirectedSelfLoopCount--;\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) graph._directedSelfLoopCount--;\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges =\n          typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected[target];\n\n      if (!edges) return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const self = nodeData.in[node];\n    const loops = self ? (this.multi ? self.size : 1) : 0;\n\n    return nodeData.inDegree - loops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const self = nodeData.out[node];\n    const loops = self ? (this.multi ? self.size : 1) : 0;\n\n    return nodeData.outDegree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    const self = nodeData.out[node];\n    const loops = self ? (this.multi ? self.size : 1) : 0;\n\n    return nodeData.inDegree + nodeData.outDegree - loops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    const self = nodeData.undirected[node];\n    const loops = self ? (this.multi ? self.size : 1) : 0;\n\n    return nodeData.undirectedDegree - loops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let self;\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n\n      self = nodeData.undirected[node];\n      loops += (self ? (this.multi ? self.size : 1) : 0) * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n\n      self = nodeData.out[node];\n      loops += self ? (this.multi ? self.size : 1) : 0;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let self;\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n\n      self = nodeData.undirected[node];\n      loops += (self ? (this.multi ? self.size : 1) : 0) * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n\n      self = nodeData.in[node];\n      loops += self ? (this.multi ? self.size : 1) : 0;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let self;\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n\n      self = nodeData.undirected[node];\n      loops += (self ? (this.multi ? self.size : 1) : 0) * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n\n      self = nodeData.out[node];\n      loops += (self ? (this.multi ? self.size : 1) : 0) * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    if (typeof Array.from === 'function') return Array.from(this._nodes.keys());\n\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done) return step;\n\n      const data = step.value;\n\n      return {\n        value: {node: data.key, attributes: data.attributes},\n        done: false\n      };\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology CommonJS Endoint\n * ============================\n *\n * Endpoint for CommonJS modules consumers.\n */\nimport {Graph} from './classes';\n\nexport default Graph;\n"],"names":["assignPolyfill","target","arguments","i","l","length","k","assign","Object","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isPlainObject","value","constructor","isEmpty","o","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","Array","isArray","incrementalIdStartingFromRandomByte","Math","floor","random","GraphError","message","Error","InvalidArgumentsGraphError","captureStackTrace","prototype","NotFoundGraphError","UsageGraphError","MixedNodeData","key","clear","inDegree","outDegree","undirectedDegree","DirectedNodeData","UndirectedNodeData","EdgeData","attach","outKey","inKey","attachMulti","adj","head","previous","next","detach","detachMulti","undefined","NODE","SOURCE","TARGET","OPPOSITE","findRelevantNodeData","method","mode","nodeOrEdge","nameOrEdge","add1","add2","nodeData","edgeData","arg1","arg2","_edges","attachNodeAttributeGetter","Class","data","attachNodeAttributesGetter","attachNodeAttributeChecker","hasOwnProperty","attachNodeAttributeSetter","emit","attachNodeAttributeUpdater","updater","attachNodeAttributeRemover","attachNodeAttributesReplacer","attachNodeAttributesMerger","attachNodeAttributesUpdater","NODE_ATTRIBUTES_METHODS","element","attacher","attachNodeAttributesMethods","Graph","forEach","attachEdgeAttributeGetter","multi","attachEdgeAttributesGetter","attachEdgeAttributeChecker","attachEdgeAttributeSetter","attachEdgeAttributeUpdater","attachEdgeAttributeRemover","attachEdgeAttributesReplacer","attachEdgeAttributesMerger","attachEdgeAttributesUpdater","EDGE_ATTRIBUTES_METHODS","attachEdgeAttributesMethods","EDGES_ITERATION","direction","forEachSimple","breakable","object","callback","avoid","shouldBreak","forEachMulti","createIterator","keys","Iterator","done","sourceAttributes","targetAttributes","forEachForKeySimple","targetData","forEachForKeyMulti","createIteratorForKey","of","createEdgeArray","size","from","take","undirectedSize","directedSize","list","mask","iterator","values","step","forEachEdge","shouldFilter","createEdgeIterator","empty","forEachEdgeForNode","fn","found","createEdgeArrayForNode","edges","push","createEdgeIteratorForNode","chain","forEachEdgeForPath","createEdgeArrayForPath","createEdgeIteratorForPath","attachEdgeArrayCreator","description","has","attachForEachEdge","forEachName","toUpperCase","slice","mapName","args","call","pop","result","e","ea","s","t","sa","ta","u","apply","filterName","reduceName","initialValue","accumulator","attachFindEdge","findEdgeName","someName","everyName","attachEdgeIteratorCreator","originalName","attachEdgeIterationMethods","NEIGHBORS_ITERATION","CompositeSetWrapper","A","B","wrap","set","forEachInObjectOnce","visited","neighborData","forEachNeighbor","createNeighborArrayForNode","neighbors","createDedupedObjectIterator","neighbor","createNeighborIterator","attachNeighborArrayCreator","node","attachForEachNeighbor","n","a","attachFindNeighbor","capitalizedSingular","findName","attachNeighborIteratorCreator","iteratorName","attachNeighborIterationMethods","forEachAdjacency","assymetric","disconnectedNodes","hasEdges","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","INSTANCE_ID","TYPES","Set","EMITTER_PROPS","EDGE_ADD_METHODS","verb","generateKey","DEFAULTS","allowSelfLoops","addNode","NodeDataClass","unsafeAddNode","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","isSelfLoop","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","alreadyExistingEdgeData","info","oldAttributes","sourceWasAdded","targetWasAdded","dropEdgeFromData","options","instancePrefix","edgeId","edgeKeyGenerator","availableEdgeKey","Map","prop","_options","_resetInstanceCounters","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","areDirectedNeighbors","areOutNeighbors","areInNeighbors","areUndirectedNeighbors","areNeighbors","areInboundNeighbors","areOutboundNeighbors","directedDegree","inboundDegree","degree","outboundDegree","inDegreeWithoutSelfLoops","self","loops","outDegreeWithoutSelfLoops","directedDegreeWithoutSelfLoops","undirectedDegreeWithoutSelfLoops","inboundDegreeWithoutSelfLoops","outboundDegreeWithoutSelfLoops","degreeWithoutSelfLoops","extremities","opposite","hasExtremity","isUndirected","isDirected","mergeNode","updateNode","dropNode","dropEdge","dropDirectedEdge","dropUndirectedEdge","clearEdges","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","updateAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachAdjacencyEntry","forEachAdjacencyEntryWithOrphans","forEachAssymetricAdjacencyEntry","forEachAssymetricAdjacencyEntryWithOrphans","nodes","forEachNode","findNode","mapNodes","order","someNode","everyNode","filterNodes","reduceNodes","nodeEntries","merge","_sa","_ta","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addUndirectedEdgeWithKey","addDirectedEdgeWithKey","undirectedByDefault","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","copy","toJSON","toString","inspect","multiIndex","label","tmp","desc","startsWith","dummy","EventEmitter","Symbol","DirectedGraph","finalOptions","UndirectedGraph","MultiGraph","MultiDirectedGraph","MultiUndirectedGraph","attachStaticFromMethod","instance"],"mappings":"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"}